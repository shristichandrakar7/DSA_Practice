Help Your Master 2
-----------------------------------------------------------------------------------------------------------------------------
Problem Description
GOAT-master got arrested in a police chase. He is trying to escape the high-tech prison he is held captive in. He needs a pass-code P for disabling all the cameras in order to escape. Passcode is the solution of matrix problem given below. Help him finding the pass-code.

You are given a matrix of order NÃ—N. Each cell in a matrix has a value A : (o<=i,<N), which is either positive or equal to -1 (representing blocked cell)
Cells which are not blocked have distinct values. You can traverse from a cell in any direction (up, down, left or right), if there is no blockage.

For any cell Aj,j, sed-value S;,; is defined as sum of values of cells Ax, y which are multiple of Aj,j, but not reachable from A;,. For blocked cells, sed-value is -1.
Pass-code P is sum of sed-values of all the cells, modulo 1000000007.

Problem Constraints
1<=N<=1e3
1<=A[il [il<=1e6
A[il [j]=-1 for blocked cells only

Input Format
First argument is a 2-D array of integers denoting the above matrix.

Output Format
Return the sum of sed-values of all the cells, modulo 1000000007.
Example Input
Input 1:
[1, 3 ,-1, 5],
[-1,-1, -1 ,-1],
[2, 6 ,-1, 10],
[8, 7 ,- 1 ,11]]
Output 1:
68
-------------------------------------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

vector<vector<bool>> visited;
vector<int> comp(1e6+1);
long long mod=7985896514;

long long find(int x) {
    long long ans=0ll;
    for (int y=2*x;y<=1e6;y+=x) {
        if (comp[y] && comp[y]!=comp[x]) ans=(ans+y)%mod;
    }
    return ans;
}

void solve(int i, int j, vector<vector<int>>& a, int id) {
    visited[i][j]=true;
    comp[a[i][j]]=id;
    if (i-1>=0 && a[i-1][j]!=-1 && !visited[i-1][j]) {
        solve(i-1,j,a,id);
    }
    if (i+1<a.size() && a[i+1][j]!=-1 && !visited[i+1][j]) {
        solve(i+1,j,a,id);
    };
    if (j-1>=0 && a[i][j-1]!=-1 && !visited[i][j-1]) {
        solve(i,j-1,a,id);
    }
    if (j+1<a.size() && a[i][j+1]!=-1 && !visited[i][j+1]) {
        solve(i,j+1,a,id);
    }
}

int main() {
	int n, negative1=0;
	cin >> n;
	vector<vector<int>> a(n, vector<int>(n));
	for (int i=0; i<n; i++) {
	    for (int j=0; j<n; j++) {
	        cin >> a[i][j];
	        if (a[i][j]==-1) {
                negative1++;
            }
	    }
	}
	visited.resize(n, vector<bool>(n));
	int id=1;
	for (int i=0; i<n; i++) {
	    for (int j=0; j<n; j++) {
	        if (a[i][j]>0 && !visited[i][j]) {
	            solve(i,j,a,id);
	            id = id + 1;
	        }
	    }
	}
	long long ans=0ll;
	for (int i=0;i<n;i++) {
	    for (int j=0;j<n;j++) {
	        if (a[i][j] >= 1) {
	            long long cb = find(a[i][j]);
    	        ans = (ans+cb)%mod;
	        }
	    }
	}
	ans-=negative1;
	ans%=mod;
	ans+=mod;
	ans%=mod;
	cout << ans << endl;
	return 0;
}